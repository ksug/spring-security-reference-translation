[[technical-overview]]
== Technical Overview


[[runtime-environment]]
////
=== Runtime Environment
Spring Security 3.0 requires a Java 5.0 Runtime Environment or higher. As Spring Security aims to operate in a self-contained manner, there is no need to place any special configuration files into your Java Runtime Environment. In particular, there is no need to configure a special Java Authentication and Authorization Service (JAAS) policy file or place Spring Security into common classpath locations.

Similarly, if you are using an EJB Container or Servlet Container there is no need to put any special configuration files anywhere, nor include Spring Security in a server classloader. All the required files will be contained within your application.

This design offers maximum deployment time flexibility, as you can simply copy your target artifact (be it a JAR, WAR or EAR) from one system to another and it will immediately work.
////
=== 런타임 환경
스프링 시큐리티 3.0 은 자바 5.0 런타임 환경이상을 필요로 합니다. 스프링 시큐리티는 독립적인 방법으로 동작하기 때문에, 당신의 자바 환경에 어떤 특정 설정파일을 추가할 필요가 없습니다. 스프링 클래스패스 위치에 특별한 자바 인증과 인증서비스 방침(JAAS)파일을 설정할 필요도 없습니다. 

비슷하게 만약 당신이 EJB 컨테이너나 서블릿 컨테이너를 사용한다면, 어떤 특정한 설정파일을을 어디에도 놓을 필요가 없고 스프링 시큐리티를 클래스 로더에 놓을 필요도 없습니다. 당신의 어플리케이션 안에 모든 필요로 하는 파일이 포함될 것입니다.

이러한 디자인은 개발기간의 유연성을 최대치로 제공하여서, 어떤 시스템에서 다른 시스템으로 대상 artifact를 복사만해도 그것은 즉시 동작할 것입니다.


[[core-components]]
////
=== Core Components
In Spring Security 3.0, the contents of the `spring-security-core` jar were stripped down to the bare minimum. It no longer contains any code related to web-application security, LDAP or namespace configuration. We'll take a look here at some of the Java types that you'll find in the core module. They represent the building blocks of the framework, so if you ever need to go beyond a simple namespace configuration then it's important that you understand what they are, even if you don't actually need to interact with them directly.
////

=== 핵심 컴포넌트
스프링 시큐리티 3.0 에서 스프링 시큐리티 코어의 컨셉은 불필요한 것들을 제거한 기초적 핵심 코어였습니다. 그것은 웹어플리케이션 보안, LDAP이나 네임스페이스 설정에 관련된 어떠한 코드에도 포함되지 않았었습니다.  우리는 여기서 코어모듈에서 발견할 수 있는 몇가지 자바 타입을 살펴보겠습니다. 이 자바타입들은 프레임워크에 필요한 구성요소들을 나타냅니다. 당신이 단순한 네임스페이스 설정 이상을 하고 싶다면, 이것들을 실제로 사용하지는 않더라도, 알아두는 것이 좋을 것입니다. 

////
====  SecurityContextHolder, SecurityContext and Authentication Objects
The most fundamental object is `SecurityContextHolder`. This is where we store details of the present security context of the application, which includes details of the principal currently using the application. By default the `SecurityContextHolder` uses a `ThreadLocal` to store these details, which means that the security context is always available to methods in the same thread of execution, even if the security context is not explicitly passed around as an argument to those methods. Using a `ThreadLocal` in this way is quite safe if care is taken to clear the thread after the present principal's request is processed. Of course, Spring Security takes care of this for you automatically so there is no need to worry about it.
////

====  SecurityContextHolder, SecurityContext and Authentication Objects
가장 기초적인 객체는 `SecurityContextHolder` 입니다. 이것은 우리가 어플리케이션 시큐리티 컨텍스트에 세부적인 사항들을 저장해두는 곳이며 어플리케이션이 현재 사용하는 접근주체(principal)의 세부적인 사항들을 포함해두는 곳입니다. 기본적으로 `SecurityContextHolder`는  `ThreadLocal`을 사용하여서 이러한 세부사항을 저장하는데 이것이 의미하는 바는 스프링 시큐리티 컨텍스트가 같은 스레드의 실행 내의 메서드들안에서 언제나 사용가능하다는 것을 의미합니다. 심지어 시큐리티 컨텍스트가 명시적으로 메서드들의 아규먼트로 전해지지 않았어도 말입니다. 현재 접근주체의 요청이 처리된 이후에 스레드를 clear 한다면 이러한 방법으로 `ThreadLocal`을 사용하는 것은 무척 안전합니다. 당연히 스프링 시큐리티는 이러한 것들을 자동적으로 처리해주기 때문에 이것들에 대해서 걱정할 필요는 없습니다. 

////
Some applications aren't entirely suitable for using a `ThreadLocal`, because of the specific way they work with threads. For example, a Swing client might want all threads in a Java Virtual Machine to use the same security context. `SecurityContextHolder` can be configured with a strategy on startup to specify how you would like the context to be stored. For a standalone application you would use the `SecurityContextHolder.MODE_GLOBAL` strategy. Other applications might want to have threads spawned by the secure thread also assume the same security identity. This is achieved by using `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL`. You can change the mode from the default `SecurityContextHolder.MODE_THREADLOCAL` in two ways. The first is to set a system property, the second is to call a static method on `SecurityContextHolder`. Most applications won't need to change from the default, but if you do, take a look at the JavaDocs for `SecurityContextHolder` to learn more.
////

어떠한 어플리케이션들은 전체적으로 `ThreadLocal`을 사용하는데 적합하지는 않습니다. 왜냐하면 그들이 스레드를 사용하는 특정한 방법때문입니다. 예를 들어서 Swing Client 는 같은 시큐리티 컨텍스트를 사용하기 위해서 자바가상머신에서 모든 스레드를 사용하기를 원할지도 모릅니다. `SecurityContextHolder`는 첫 기동되는 동안에 어떻게 컨텍스트가 저장될지에 관한 전략을 설정할 수 있습니다. 독립적인 어플리케이션을 위해서는 `SecurityContextHolder.MODE_GLOBAL` 전략을 사용할 수 있습니다. 다른 어플리케이션들은 보안스레드에 의해 만들어진 스레드를 가지길 원할지 모르며, 또한 같은 보안식별자를 추정할지도 모릅니다.  이것은 `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL`에 의해 이뤄질 수 있습니다. 당신은 기본값인 `SecurityContextHolder.MODE_THREADLOCAL` 를 두가지 방법으로 바꿀 수 있습니다.  첫번째는 시스템 프로퍼티를 설정하는 것입니다. 두번째는 정적메서드  `SecurityContextHolder`를 호출하는 것입니다. 대부분의 어플리케이션들은 기본값에서 바뀌길 원하진 않지만, 만약 원한다면 `SecurityContextHolder` 에 관련된 자바문서를 더 살펴보세요. 

////
===== Obtaining information about the current user
Inside the `SecurityContextHolder` we store details of the principal currently interacting with the application. Spring Security uses an `Authentication` object to represent this information. You won't normally need to create an `Authentication` object yourself, but it is fairly common for users to query the `Authentication` object. You can use the following code block - from anywhere in your application - to obtain the name of the currently authenticated user, for example:
////

===== 현재 유저에 대한 정보를 얻기
`SecurityContextHolder` 에서 현재 어플리케이션과 상호작용하는 유저의 세부정보를 알 수가 있습니다. 스프링 시큐리티는 `Authentication` 객체를 사용하여서 이러한 정보를 표현하고 있습니다. 당신은 보통 `Authentication` 객체를 직접 만들고 싶지는 않지만,  `Authentication`객체에 대해서 매우 흔하게 질의를 날릴 것입니다. 당신은 다음의 코드 블록을 통해서 당신의 어플리케이션 어느곳 에서건 현재 인증된 유저의 이름을 얻을 수 있습니다. 예를 들자면 다음과 같습니다. 


[source,java]
----

Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) {
String username = ((UserDetails)principal).getUsername();
} else {
String username = principal.toString();
}
----

////
The object returned by the call to `getContext()` is an instance of the `SecurityContext` interface. This is the object that is kept in thread-local storage. As we'll see below, most authentication mechanisms withing Spring Security return an instance of `UserDetails` as the principal.
////

`getContext()` 를 호출하여서 얻어지는 객체는 `SecurityContext`  인터페이스의 인스턴스 입니다. 이것은 스레드 로컬 저장소에 보관된 객체 입니다. 우리가 보는 것과 마찬가지로 대부분의 인증 메커니즘은 `UserDetails`를 principal 의 인스턴스로 리턴합니다. 


////
[[tech-userdetailsservice]]
==== The UserDetailsService
Another item to note from the above code fragment is that you can obtain a principal from the `Authentication` object. The principal is just an `Object`. Most of the time this can be cast into a `UserDetails` object. `UserDetails` is a core interface in Spring Security. It represents a principal, but in an extensible and application-specific way. Think of `UserDetails` as the adapter between your own user database and what Spring Security needs inside the `SecurityContextHolder`. Being a representation of something from your own user database, quite often you will cast the `UserDetails` to the original object that your application provided, so you can call business-specific methods (like `getEmail()`, `getEmployeeNumber()` and so on).
////

==== UserDetailsService
위의 코드조각에서 주목할만한 다른 것은 `Authentication` 객체에서 principal 을 얻을 수 있다는 것입니다. principal 은 단지 객체이며, 대부분 `UserDetails` 객체로 형변환이 가능합니다. `UserDetails` 은 스프링 시큐리티의 핵심 인터페이스 입니다. 이것은 principal 을 표현하지만, 어플리케이션 특정한 방법으로 확장가능합니다. `UserDetails`를 당신의 데이터베이스와 `SecurityContextHolder` 내의 스프링 시큐리티가 필요로 하는 것 사이의 어답터라고 생각해봅시다. 당신의 데이터베이스로부터 얻은 어떤 것으로부터 당신은 `UserDetails`를 어플리케이션이 제공하는 원본객체로 형변환할 것입니다. 그래서 당신은 `getEmail()`, `getEmployeeNumber()` 같은 비즈니스적인 메서드들을 호출할 수가 있게 되는 것입니다. 


////
By now you're probably wondering, so when do I provide a `UserDetails` object? How do I do that? I thought you said this thing was declarative and I didn't need to write any Java code - what gives? The short answer is that there is a special interface called `UserDetailsService`. The only method on this interface accepts a `String`-based username argument and returns a `UserDetails`:
////
지금까지 당신은 아마 궁금해할지도 모릅니다. 그럼 언제 내가 `UserDetails`객체를 제공해야 하는 것인가? 어떻게 그럴 수 있지 ? 나는 이것이 선언적이고 (declarative) 나는 어떠한 자바코드도 적길 원하지 않았는데 말이지.. 무엇을 줄까?.. 이것에 대한 짧은 답변은 `UserDetailsService` 라 불리는 특별한 인터페이스가 있다는 것입니다. 유저네임 아규먼트를 받는 이 인터페이스의 유일한 메서드가 있으며, `UserDetails`를 반환한다는 것입니다. 

[source,java]
----

UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
----

////
This is the most common approach to loading information for a user within Spring
				Security and you will see it used throughout the framework whenever information on a
				user is required.
////

이것은 스프링 시큐리티에서 유저를 위해 정보를 불러오는 것에 접근하는 가장 흔한 방법으로 당신은 유저가 필요할 때마다 프레임워크 전반에서 이것이 사용되는 것을 보실 수가 있을 겁니다.

////
On successful authentication, `UserDetails` is used to build the `Authentication` object that is stored in the `SecurityContextHolder` (more on this <<tech-intro-authentication,below>>). The good news is that we provide a number of `UserDetailsService` implementations, including one that uses an in-memory map (`InMemoryDaoImpl`) and another that uses JDBC (`JdbcDaoImpl`). Most users tend to write their own, though, with their implementations often simply sitting on top of an existing Data Access Object (DAO) that represents their employees, customers, or other users of the application. Remember the advantage that whatever your `UserDetailsService` returns can always be obtained from the `SecurityContextHolder` using the above code fragment.
////

인증이 성공적으로 진행되면, `UserDetails`는 `SecurityContextHolder`에 보관되는 `Authentication`객체를 만들어냅니다. (좀 더 많은 내용은 <<tech-intro-authentication,below>>) 를 보세요). 좋은 소식은 우리는 인메모리 맵 기반의 (`InMemoryDaoImpl`) JDBC를 사용하는 `JdbcDaoImpl` 등등 꽤 많은 `UserDetailsService` 구현체들을 제공한다는 것입니다. 그러나 대부분의 사용자들은 그들 자신의 간단한 구현체를 (그들 어플리케이션에서 직원, 고객 다른 사용자들을 나타나내는 ) DAO 계층 위에 올려둡니다.  어떤 `UserDetailsService`이든  위의 코드 조각을 사용하여서  `SecurityContextHolder` 로부터 정보가 얻어진 다는 것을 기억하세요. 

////
[NOTE]
====

There is often some confusion about `UserDetailsService`. It is purely a DAO for user data and performs no other function other than to supply that data to other components within the framework. In particular, it __does not__ authenticate the user, which is done by the `AuthenticationManager`. In many cases it makes more sense to <<core-services-authentication-manager,implement `AuthenticationProvider`>> directly if you require a custom authentication process.

====
////

[NOTE]
====

 `UserDetailsService` 에 대한 약간의 혼동이 있을 수 있습니다. `UserDetailsService`는 순수하게 유저데이터를 위한 DAO 이며 프레임워크내에서 유저데이터를 다른 컴포넌트에게 제공하는 일 외에 다른 기능을 수행하지 않습니다. 특별히 유저 인증을 수행하지는 않으며, 이것은 `AuthenticationManager`에 의해 이뤄집니다. 당신이 커스텀한 인증 프로세스를 원하는 경우에  (<<core-services-authentication-manager,implement `AuthenticationProvider`>>) <<`AuthenticationProvider`를 구현하는 핵심 서비스 인증 매니저>> 가 직접적으로 하는 것이 더 맞다고 볼 수 있습니다. 

////
[[tech-granted-authority]]
==== GrantedAuthority
Besides the principal, another important method provided by `Authentication` is `getAuthorities()`. This method provides an array of `GrantedAuthority` objects. A `GrantedAuthority` is, not surprisingly, an authority that is granted to the principal. Such authorities are usually "roles", such as `ROLE_ADMINISTRATOR` or `ROLE_HR_SUPERVISOR`. These roles are later on configured for web authorization, method authorization and domain object authorization. Other parts of Spring Security are capable of interpreting these authorities, and expect them to be present. `GrantedAuthority` objects are usually loaded by the `UserDetailsService`.

Usually the `GrantedAuthority` objects are application-wide permissions. They are not specific to a given domain object. Thus, you wouldn't likely have a `GrantedAuthority` to represent a permission to `Employee` object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user). Of course, Spring Security is expressly designed to handle this common requirement, but you'd instead use the project's domain object security capabilities for this purpose.

////

[[tech-granted-authority]]
==== 인정된 권한
principal 외에 `Authentication` 에 의해 제공되는 다른 중요한 메소드는 `getAuthorities()` 입니다. 이 메소드는 `GrantedAuthority` 객체 배열을 제공합니다.   `GrantedAuthority`는 놀랍지 않게 printipal 에 부여된 권한입니다. 이러한 권한은 보통 `ROLE_ADMINISTRATOR` or `ROLE_HR_SUPERVISOR` 같은 "roles" 로 말합니다. 이러한 roles 은 나중에 웹 인증이나 메소드 인증이나 도메인 객체 인증을 위하여 설정되게 됩니다. 스프링 시큐리티의 다른 부분들은 이러한 권한 처리를 할 수 있습니다.  `GrantedAuthority`는 보통 `UserDetailsService` 에 의해 불러와지게 됩니다. 

보통 `GrantedAuthority`객체는 어플리케이션의 내에서 권한으로 넓게 사용됩니다. 이것들은 어떤 특정한 도메인 객체에 국한되지 않습니다. 그러므로 당신은 `GrantedAuthority`를  54번째의 `Employee`객체의 권한을 표현하는데 사용할 필요가 없습니다. 왜냐하면 만약 수천개의 권한이 있다면 당신의 메모리는 급속하게 메모리가 부족해질 것이기 때문입니다. (아니라면 적어도 유저 인증을 수행하는데  많은 시간이 걸릴 것입니다.)
스프링 시큐리티는 명확하게 이러한 공통 요구사항을 처리하기 위해 디자인 되었습니다만, 프로젝트의 도메인 객체 시큐리티기능을 사용할 수 있습니다. 


////
==== Summary
Just to recap, the major building blocks of Spring Security that we've seen so far are:


* `SecurityContextHolder`, to provide access to the `SecurityContext`.

* `SecurityContext`, to hold the `Authentication` and possibly request-specific security information.

* `Authentication`, to represent the principal in a Spring Security-specific manner.

* `GrantedAuthority`, to reflect the application-wide permissions granted to a principal.

* `UserDetails`, to provide the necessary information to build an Authentication object from your application's DAOs or other source of security data.

* `UserDetailsService`, to create a `UserDetails` when passed in a `String`-based username (or certificate ID or the like).
////

==== 요약
요약을 위해서, 스프링 시큐리티의 주요 부분은 다음과 같습니다. 
* `SecurityContextHolder`, 는 `SecurityContext` 에 대한 접근을 제공합니다.

* `SecurityContext`는  `Authentication` 을 가지고 있고, 특정요청 보안정보를 가지고 있을 수 있습니다. 

* `Authentication` 는 스프링 시큐리티의 방법으로 principal 을 표현합니다. 

* `GrantedAuthority`는 principal 에 허용된 어플리케이션 전체적인 권한을 나타냅니다. 

* `UserDetails` 는 당신의 어플리케이션의 DAO나 다른 시큐리티데이터의 소스로부터 Authentication 객체를 만들어내는데 필요한 정보를 제공합니다. 

* `UserDetailsService`는  `String`기반의 유저네임(혹은 인증 ID같은 것들) 이 전달되면 `UserDetails`  를 생성합니다. 


////
Now that you've gained an understanding of these repeatedly-used components, let's take a closer look at the process of authentication.
////

반복적으로 사용되는 컴포넌트에 관해서 이해를 하였기 때문에 좀 더 인증 프로세스를 알아보도록 하겠습니다. 


[[tech-intro-authentication]]
////
=== Authentication
Spring Security can participate in many different authentication environments. While we recommend people use Spring Security for authentication and not integrate with existing Container Managed Authentication, it is nevertheless supported - as is integrating with your own proprietary authentication system.
////

=== 인증
스프링 시큐리티는 많은 인증환경을 처리할 수 있습니다. 우리는 인증에 스프링 시큐리티를 사용하기를 추천하지만, 존재하는 인증관리 콘테이너와 통합하기를 추천하지는 않지만 이것은 지원됩니다. 

////
==== What is authentication in Spring Security?
Let's consider a standard authentication scenario that everyone is familiar with.

. A user is prompted to log in with a username and password.
. The system (successfully) verifies that the password is correct for the username.
. The context information for that user is obtained (their list of roles and so on).
. A security context is established for the user
. The user proceeds, potentially to perform some operation which is potentially protected by an access control mechanism which checks the required permissions for the operation against the current security context information.
////

==== 스프링 시큐리티에서 인증이란 무엇일까요?
모두가 친숙한 표준 인증 시나리오를 알아보도록 하겠습니다.
. 사용자가 유저이름과 비밀번호를 치고 로그인을 하려합니다.
. 시스템은 성공적으로 해당 유저이름에 비밀번호가 맞는지 검사합니다.
. 해당 유저를 위한 콘텍스트 정보가 얻어집니다. (권한 리스트 같은 것)
. 시큐리티 콘텍스트가 유저를 위해서 설정됩니다.
. 유저는 잠재적으로 어떤 접근제어메커니즘을 가지고 있는 작업들을 할 수 있게 됩니다. 

////
The first three items constitute the authentication process so we'll take a look at how these take place within Spring Security.

. The username and password are obtained and combined into an instance of `UsernamePasswordAuthenticationToken` (an instance of the `Authentication` interface, which we saw earlier).
. The token is passed to an instance of `AuthenticationManager` for validation.
. The `AuthenticationManager` returns a fully populated `Authentication` instance on successful authentication.
. The security context is established by calling `SecurityContextHolder.getContext().setAuthentication(...)`, passing in the returned authentication object.

From that point on, the user is considered to be authenticated. Let's look at some code as an example.
////

첫번째 세가지 아이템은 인증 프로세스를 구성합니다. 그래서 우리는 어떻게 이것들이 스프링 시큐리티에서 이뤄지는지 보도록 하겠습니다.
. 유저네임과 비밀번호가 `UsernamePasswordAuthenticationToken` 의 인스턴스로 조합이 되어서 만들어집니다. (이전에 본 `Authentication`인터페이스의 인스턴스입니다)
. 토큰이 인증을 위해 `AuthenticationManager` 로 전달되어집니다. 
.  `AuthenticationManager` 는 성공적인 인증 후에  `Authentication` 인스턴스를 생성해 반환합니다. 
. 시큐리티 콘텍스트가 `SecurityContextHolder.getContext().setAuthentication(...)`를 호출함으로써 설정되며 반환된 인증 객체를 전달합니다. 


[source,java]
----
import org.springframework.security.authentication.*;
import org.springframework.security.core.*;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

public class AuthenticationExample {
private static AuthenticationManager am = new SampleAuthenticationManager();

public static void main(String[] args) throws Exception {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

	while(true) {
	System.out.println("Please enter your username:");
	String name = in.readLine();
	System.out.println("Please enter your password:");
	String password = in.readLine();
	try {
		Authentication request = new UsernamePasswordAuthenticationToken(name, password);
		Authentication result = am.authenticate(request);
		SecurityContextHolder.getContext().setAuthentication(result);
		break;
	} catch(AuthenticationException e) {
		System.out.println("Authentication failed: " + e.getMessage());
	}
	}
	System.out.println("Successfully authenticated. Security context contains: " +
			SecurityContextHolder.getContext().getAuthentication());
}
}

class SampleAuthenticationManager implements AuthenticationManager {
static final List<GrantedAuthority> AUTHORITIES = new ArrayList<GrantedAuthority>();

static {
	AUTHORITIES.add(new SimpleGrantedAuthority("ROLE_USER"));
}

public Authentication authenticate(Authentication auth) throws AuthenticationException {
	if (auth.getName().equals(auth.getCredentials())) {
	return new UsernamePasswordAuthenticationToken(auth.getName(),
		auth.getCredentials(), AUTHORITIES);
	}
	throw new BadCredentialsException("Bad Credentials");
}
}
----
////
Here
				we have written a little program that asks the user to enter a username and password
				and performs the above sequence. The
				`AuthenticationManager` which we've implemented here will authenticate any user whose username and password are the same. It assigns a single role to every user. The output from the above will be something like:

////

우리는 유저에게 유저네임과 비밀번호를 묻고 위의 순서를 실행하는 작은 프로그램을 작성하였습니다. 우리가 여기서 구현한 `AuthenticationManager` 는 유저네임과 비밀번호가 같은 어떤 유저든 인증처리를 합니다. 이것은 모든 유저에게 하나의 권한을 부여하며 이것으로부터의 결과는 다음과 같은 것입니다. 


[source,txt]
----

Please enter your username:
bob
Please enter your password:
password
Authentication failed: Bad Credentials
Please enter your username:
bob
Please enter your password:
bob
Successfully authenticated. Security context contains: \
org.springframework.security.authentication.UsernamePasswordAuthenticationToken@441d0230: \
Principal: bob; Password: [PROTECTED]; \
Authenticated: true; Details: null; \
Granted Authorities: ROLE_USER

----


////
Note that you don't normally need to write any code like this. The process will normally occur internally, in a web authentication filter for example. We've just included the code here to show that the question of what actually constitutes authentication in Spring Security has quite a simple answer. A user is authenticated when the `SecurityContextHolder` contains a fully populated `Authentication` object.
////
당신은 보통 다음과 같은 코드를 적을 필요가 없습니다. 이러한 과정은 보통 예를 들자면 웹어플리케이션 필터에서 내부적으로 일어납니다. 우리는 스프링 시큐리티에서 무엇이 실제적으로 인증을 구성하는 지에 대한 질문에 대한 답을 간단히 보여주기 위해 다음과 같은 코드를 포함하였습니다. `SecurityContextHolder` 가 완벽히 생성된 `Authentication` 객체를 포함할때 인증은 이뤄집니다. 


////
==== Setting the SecurityContextHolder Contents Directly
In fact, Spring Security doesn't mind how you put the `Authentication` object inside the `SecurityContextHolder`. The only critical requirement is that the `SecurityContextHolder` contains an `Authentication` which represents a principal before the `AbstractSecurityInterceptor` (which we'll see more about later) needs to authorize a user operation.
////

==== 직접적으로 SecurityContextHolder 내용을 세팅하기
실제로, 스프링 시큐리티는 `SecurityContextHolder`내부에  `Authentication` 객체가 어떻게 놓여질지는 신경쓰지 않습니다. 
중요한 요구사항은 `AbstractSecurityInterceptor`가 유저 작업을 인증할 필요가 있기전에, `SecurityContextHolder`가  principal을 포함하고 있는 `Authentication`를 가지고 있는 것입니다. 

////
You can (and many users do) write their own filters or MVC controllers to provide interoperability with authentication systems that are not based on Spring Security. For example, you might be using Container-Managed Authentication which makes the current user available from a ThreadLocal or JNDI location. Or you might work for a company that has a legacy proprietary authentication system, which is a corporate "standard" over which you have little control. In situations like this it's quite easy to get Spring Security to work, and still provide authorization capabilities. All you need to do is write a filter (or equivalent) that reads the third-party user information from a location, build a Spring Security-specific `Authentication` object, and put it into the `SecurityContextHolder`. In this case you also need to think about things which are normally taken care of automatically by the built-in authentication infrastructure. For example, you might need to pre-emptively create an HTTP session to <<tech-intro-sec-context-persistence,cache the context between requests>>, before you write the response to the client footnote:[It isn't possible to create a session once the response has been committed.
////

당신과 많은 사용자들은 그들의 자신의 필터를 만들거나 MVC컨트롤러를 만들어서 스프링 시큐리티에 기반을 두고 있지 않은 인증시스템과 상호작용할 수 있습니다. 예를 들자면 당신이 쓰레드로컬이나 JNDI위치에 기반하여서 사용자를 사용가능하게 하는 인증관리콘테이너를 사용하고 있거나, 레거시 인증 시스템을 사용하는 회사와 일을 하고 있다고 해봅시다. 

If you're wondering how the `AuthenticationManager` is implemented in a real world example, we'll look at that in the <<core-services-authentication-manager,core services chapter>>.


[[tech-intro-web-authentication]]
=== Authentication in a Web Application
Now let's explore the situation where you are using Spring Security in a web application (without `web.xml` security enabled). How is a user authenticated and the security context established?

Consider a typical web application's authentication process:


. You visit the home page, and click on a link.
. A request goes to the server, and the server decides that you've asked for a protected resource.
. As you're not presently authenticated, the server sends back a response indicating that you must authenticate. The response will either be an HTTP response code, or a redirect to a particular web page.
. Depending on the authentication mechanism, your browser will either redirect to the specific web page so that you can fill out the form, or the browser will somehow retrieve your identity (via a BASIC authentication dialogue box, a cookie, a X.509 certificate etc.).
. The browser will send back a response to the server. This will either be an HTTP POST containing the contents of the form that you filled out, or an HTTP header containing your authentication details.
. Next the server will decide whether or not the presented credentials are valid. If they're valid, the next step will happen. If they're invalid, usually your browser will be asked to try again (so you return to step two above).
. The original request that you made to cause the authentication process will be retried. Hopefully you've authenticated with sufficient granted authorities to access the protected resource. If you have sufficient access, the request will be successful. Otherwise, you'll receive back an HTTP error code 403, which means "forbidden".

Spring Security has distinct classes responsible for most of the steps described above. The main participants (in the order that they are used) are the `ExceptionTranslationFilter`, an `AuthenticationEntryPoint` and an "authentication mechanism", which is responsible for calling the `AuthenticationManager` which we saw in the previous section.


==== ExceptionTranslationFilter
`ExceptionTranslationFilter` is a Spring Security filter that has responsibility for detecting any Spring Security exceptions that are thrown. Such exceptions will generally be thrown by an `AbstractSecurityInterceptor`, which is the main provider of authorization services. We will discuss `AbstractSecurityInterceptor` in the next section, but for now we just need to know that it produces Java exceptions and knows nothing about HTTP or how to go about authenticating a principal. Instead the `ExceptionTranslationFilter` offers this service, with specific responsibility for either returning error code 403 (if the principal has been authenticated and therefore simply lacks sufficient access - as per step seven above), or launching an `AuthenticationEntryPoint` (if the principal has not been authenticated and therefore we need to go commence step three).


[[tech-intro-auth-entry-point]]
==== AuthenticationEntryPoint
The `AuthenticationEntryPoint` is responsible for step three in the above list. As you can imagine, each web application will have a default authentication strategy (well, this can be configured like nearly everything else in Spring Security, but let's keep it simple for now). Each major authentication system will have its own `AuthenticationEntryPoint` implementation, which typically performs one of the actions described in step 3.


==== Authentication Mechanism
Once your browser submits your authentication credentials (either as an HTTP form post or HTTP header) there needs to be something on the server that"collects" these authentication details. By now we're at step six in the above list. In Spring Security we have a special name for the function of collecting authentication details from a user agent (usually a web browser), referring to it as the "authentication mechanism". Examples are form-base login and Basic authentication. Once the authentication details have been collected from the user agent, an `Authentication` "request" object is built and then presented to the `AuthenticationManager`.

After the authentication mechanism receives back the fully-populated `Authentication` object, it will deem the request valid, put the `Authentication` into the `SecurityContextHolder`, and cause the original request to be retried (step seven above). If, on the other hand, the `AuthenticationManager` rejected the request, the authentication mechanism will ask the user agent to retry (step two above).


[[tech-intro-sec-context-persistence]]
==== Storing the SecurityContext between requests
Depending on the type of application, there may need to be a strategy in place to store the security context between user operations. In a typical web application, a user logs in once and is subsequently identified by their session Id. The server caches the principal information for the duration session. In Spring Security, the responsibility for storing the `SecurityContext` between requests falls to the `SecurityContextPersistenceFilter`, which by default stores the context as an `HttpSession` attribute between HTTP requests. It restores the context to the `SecurityContextHolder` for each request and, crucially, clears the `SecurityContextHolder` when the request completes. You shouldn't interact directly with the `HttpSession` for security purposes. There is simply no justification for doing so - always use the `SecurityContextHolder` instead.

Many other types of application (for example, a stateless RESTful web service) do not use HTTP sessions and will re-authenticate on every request. However, it is still important that the `SecurityContextPersistenceFilter` is included in the chain to make sure that the `SecurityContextHolder` is cleared after each request.

[NOTE]
====
In an application which receives concurrent requests in a single session, the same `SecurityContext` instance will be shared between threads. Even though a `ThreadLocal` is being used, it is the same instance that is retrieved from the `HttpSession` for each thread. This has implications if you wish to temporarily change the context under which a thread is running. If you just use `SecurityContextHolder.getContext()`, and call `setAuthentication(anAuthentication)` on the returned context object, then the `Authentication` object will change in __all__ concurrent threads which share the same `SecurityContext` instance. You can customize the behaviour of `SecurityContextPersistenceFilter` to create a completely new `SecurityContext` for each request, preventing changes in one thread from affecting another. Alternatively you can create a new instance just at the point where you temporarily change the context. The method `SecurityContextHolder.createEmptyContext()` always returns a new context instance.
====

[[tech-intro-access-control]]
=== Access-Control (Authorization) in Spring Security
The main interface responsible for making access-control decisions in Spring Security is the `AccessDecisionManager`. It has a `decide` method which takes an `Authentication` object representing the principal requesting access, a "secure object" (see below) and a list of security metadata attributes which apply for the object (such as a list of roles which are required for access to be granted).


==== Security and AOP Advice
If you're familiar with AOP, you'd be aware there are different types of advice available: before, after, throws and around. An around advice is very useful, because an advisor can elect whether or not to proceed with a method invocation, whether or not to modify the response, and whether or not to throw an exception. Spring Security provides an around advice for method invocations as well as web requests. We achieve an around advice for method invocations using Spring's standard AOP support and we achieve an around advice for web requests using a standard Filter.

For those not familiar with AOP, the key point to understand is that Spring Security can help you protect method invocations as well as web requests. Most people are interested in securing method invocations on their services layer. This is because the services layer is where most business logic resides in current-generation Java EE applications. If you just need to secure method invocations in the services layer, Spring's standard AOP will be adequate. If you need to secure domain objects directly, you will likely find that AspectJ is worth considering.

You can elect to perform method authorization using AspectJ or Spring AOP, or you can elect to perform web request authorization using filters. You can use zero, one, two or three of these approaches together. The mainstream usage pattern is to perform some web request authorization, coupled with some Spring AOP method invocation authorization on the services layer.


[[secure-objects]]
==== Secure Objects and the AbstractSecurityInterceptor
So what __is__ a "secure object" anyway? Spring Security uses the term to refer to any object that can have security (such as an authorization decision) applied to it. The most common examples are method invocations and web requests.

Each supported secure object type has its own interceptor class, which is a subclass of `AbstractSecurityInterceptor`. Importantly, by the time the `AbstractSecurityInterceptor` is called, the `SecurityContextHolder` will contain a valid `Authentication` if the principal has been authenticated.

`AbstractSecurityInterceptor` provides a consistent workflow for handling secure object requests, typically:

. Look up the "configuration attributes" associated with the present request
. Submitting the secure object, current `Authentication` and configuration attributes to the `AccessDecisionManager` for an authorization decision
. Optionally change the `Authentication` under which the invocation takes place
. Allow the secure object invocation to proceed (assuming access was granted)
. Call the `AfterInvocationManager` if configured, once the invocation has returned. If the invocation raised an exception, the `AfterInvocationManager` will not be invoked.

[[tech-intro-config-attributes]]
===== What are Configuration Attributes?
A "configuration attribute" can be thought of as a String that has special meaning to the classes used by `AbstractSecurityInterceptor`. They are represented by the interface `ConfigAttribute` within the framework. They may be simple role names or have more complex meaning, depending on the how sophisticated the `AccessDecisionManager` implementation is. The `AbstractSecurityInterceptor` is configured with a `SecurityMetadataSource` which it uses to look up the attributes for a secure object. Usually this configuration will be hidden from the user. Configuration attributes will be entered as annotations on secured methods or as access attributes on secured URLs. For example, when we saw something like `<intercept-url pattern='/secure/**' access='ROLE_A,ROLE_B'/>` in the namespace introduction, this is saying that the configuration attributes `ROLE_A` and `ROLE_B` apply to web requests matching the given pattern. In practice, with the default `AccessDecisionManager` configuration, this means that anyone who has a `GrantedAuthority` matching either of these two attributes will be allowed access. Strictly speaking though, they are just attributes and the interpretation is dependent on the `AccessDecisionManager` implementation. The use of the prefix `ROLE_` is a marker to indicate that these attributes are roles and should be consumed by Spring Security's `RoleVoter`. This is only relevant when a voter-based `AccessDecisionManager` is in use. We'll see how the `AccessDecisionManager` is implemented in the <<authz-arch,authorization chapter>>.


===== RunAsManager
Assuming `AccessDecisionManager` decides to allow the request, the `AbstractSecurityInterceptor` will normally just proceed with the request. Having said that, on rare occasions users may want to replace the `Authentication` inside the `SecurityContext` with a different `Authentication`, which is handled by the `AccessDecisionManager` calling a `RunAsManager`. This might be useful in reasonably unusual situations, such as if a services layer method needs to call a remote system and present a different identity. Because Spring Security automatically propagates security identity from one server to another (assuming you're using a properly-configured RMI or HttpInvoker remoting protocol client), this may be useful.


===== AfterInvocationManager
Following the secure object invocation proceeding and then returning - which may mean a method invocation completing or a filter chain proceeding - the `AbstractSecurityInterceptor` gets one final chance to handle the invocation. At this stage the `AbstractSecurityInterceptor` is interested in possibly modifying the return object. We might want this to happen because an authorization decision couldn't be made "on the way in" to a secure object invocation. Being highly pluggable, `AbstractSecurityInterceptor` will pass control to an `AfterInvocationManager` to actually modify the object if needed. This class can even entirely replace the object, or throw an exception, or not change it in any way as it chooses. The after-invocation checks will only be executed if the invocation is successful. If an exception occurs, the additional checks will be skipped.

`AbstractSecurityInterceptor` and its related objects are shown in <<abstract-security-interceptor>>

[[abstract-security-interceptor]]
.Security interceptors and the "secure object" model
image::images/security-interception.png[Abstract Security Interceptor]

===== Extending the Secure Object Model
Only developers contemplating an entirely new way of intercepting and authorizing requests would need to use secure objects directly. For example, it would be possible to build a new secure object to secure calls to a messaging system. Anything that requires security and also provides a way of intercepting a call (like the AOP around advice semantics) is capable of being made into a secure object. Having said that, most Spring applications will simply use the three currently supported secure object types (AOP Alliance `MethodInvocation`, AspectJ `JoinPoint` and web request `FilterInvocation`) with complete transparency.


[[localization]]
=== Localization
Spring Security supports localization of exception messages that end users are likely to see. If your application is designed for English-speaking users, you don't need to do anything as by default all Security messages are in English. If you need to support other locales, everything you need to know is contained in this section.

All exception messages can be localized, including messages related to authentication failures and access being denied (authorization failures). Exceptions and logging messages that are focused on developers or system deployers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security's code.

Shipping in the `spring-security-core-xx.jar` you will find an `org.springframework.security` package that in turn contains a `messages.properties` file, as well as localized versions for some common languages. This should be referred to by your `ApplicationContext`, as Spring Security classes implement Spring's `MessageSourceAware` interface and expect the message resolver to be dependency injected at application context startup time. Usually all you need to do is register a bean inside your application context to refer to the messages. An example is shown below:

[source,xml]
----
<bean id="messageSource"
	class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
<property name="basename" value="classpath:org/springframework/security/messages"/>
</bean>
----

The `messages.properties` is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages. This default file is in English.

If you wish to customize the `messages.properties` file, or support other languages, you should copy the file, rename it accordingly, and register it inside the above bean definition. There are not a large number of message keys inside this file, so localization should not be considered a major initiative. If you do perform localization of this file, please consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of `messages.properties`.

Spring Security relies on Spring's localization support in order to actually lookup the appropriate message. In order for this to work, you have to make sure that the locale from the incoming request is stored in Spring's `org.springframework.context.i18n.LocaleContextHolder`. Spring MVC's `DispatcherServlet` does this for your application automatically, but since Spring Security's filters are invoked before this, the `LocaleContextHolder` needs to be set up to contain the correct `Locale` before the filters are called. You can either do this in a filter yourself (which must come before the Spring Security filters in `web.xml`) or you can use Spring's `RequestContextFilter`.  Please refer to the Spring Framework documentation for further details on using localization with Spring.

The "contacts" sample application is set up to use localized messages.
